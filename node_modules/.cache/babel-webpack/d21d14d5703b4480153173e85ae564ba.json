{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { assign, cloneDeep, omit } from 'lodash-es';\nimport * as moment from 'moment';\nimport { rrulestr } from 'rrule';\nimport { FuseMockApiUtils } from '@fuse/lib/mock-api';\nimport { calendars as calendarsData, events as eventsData, exceptions as exceptionsData, settings as settingsData, weekdays as weekdaysData } from 'app/mock-api/apps/calendar/data';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@fuse/lib/mock-api\";\nexport let CalendarMockApi = /*#__PURE__*/(() => {\n  class CalendarMockApi {\n    /**\r\n     * Constructor\r\n     */\n    constructor(_fuseMockApiService) {\n      this._fuseMockApiService = _fuseMockApiService;\n      this._calendars = calendarsData;\n      this._events = eventsData;\n      this._exceptions = exceptionsData;\n      this._settings = settingsData;\n      this._weekdays = weekdaysData; // Register Mock API handlers\n\n      this.registerHandlers();\n    } // -----------------------------------------------------------------------------------------------------\n    // @ Public methods\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\r\n     * Register Mock API handlers\r\n     */\n\n\n    registerHandlers() {\n      // -----------------------------------------------------------------------------------------------------\n      // @ Calendars - GET\n      // -----------------------------------------------------------------------------------------------------\n      this._fuseMockApiService.onGet('api/apps/calendar/calendars').reply(() => {\n        // Clone the calendars\n        const calendars = cloneDeep(this._calendars); // Return the response\n\n        return [200, calendars];\n      }); // -----------------------------------------------------------------------------------------------------\n      // @ Calendars - POST\n      // -----------------------------------------------------------------------------------------------------\n\n\n      this._fuseMockApiService.onPost('api/apps/calendar/calendars').reply(({\n        request\n      }) => {\n        // Get the calendar as the new calendar\n        const newCalendar = cloneDeep(request.body.calendar); // Add an id to the new calendar\n\n        newCalendar.id = FuseMockApiUtils.guid(); // Push the new calendar\n\n        this._calendars.push(newCalendar); // Return the response\n\n\n        return [200, newCalendar];\n      }); // -----------------------------------------------------------------------------------------------------\n      // @ Calendars - PATCH\n      // -----------------------------------------------------------------------------------------------------\n\n\n      this._fuseMockApiService.onPatch('api/apps/calendar/calendars').reply(({\n        request\n      }) => {\n        // Get the id and calendar\n        const id = request.body.id;\n        const calendar = cloneDeep(request.body.calendar); // Prepare the updated calendar\n\n        let updatedCalendar = null; // Find the calendar and update it\n\n        this._calendars.forEach((item, index, calendars) => {\n          if (item.id === id) {\n            // Update the calendar\n            calendars[index] = assign({}, calendars[index], calendar); // Store the updated calendar\n\n            updatedCalendar = calendars[index];\n          }\n        }); // Return the response\n\n\n        return [200, updatedCalendar];\n      }); // -----------------------------------------------------------------------------------------------------\n      // @ Calendars - DELETE\n      // -----------------------------------------------------------------------------------------------------\n\n\n      this._fuseMockApiService.onDelete('api/apps/calendar/calendars').reply(({\n        request\n      }) => {\n        // Get the id\n        const id = request.params.get('id'); // Find the calendar and delete it\n\n        const index = this._calendars.findIndex(calendar => calendar.id === id);\n\n        this._calendars.splice(index, 1); // Find the events that belong to the calendar and remove them as well\n\n\n        this._events = this._events.filter(event => event.calendarId !== id); // Return the response\n\n        return [200, true];\n      }); // -----------------------------------------------------------------------------------------------------\n      // @ Events - GET\n      // -----------------------------------------------------------------------------------------------------\n\n\n      this._fuseMockApiService.onGet('api/apps/calendar/events').reply(({\n        request\n      }) => {\n        // Get the start and end dates as moment\n        const viewStart = moment(request.params.get('start')).startOf('day');\n        const viewEnd = moment(request.params.get('end')).endOf('day'); // Clone the events\n\n        const events = cloneDeep(this._events); // Prepare the results\n\n        const results = []; // Go through the events...\n\n        events.forEach(event => {\n          // Get the event's start and end dates as moment\n          const eventStart = moment(event.start);\n          const eventEnd = moment(event.end); // If it's a normal event...\n\n          if (!event.recurrence) {\n            // Only grab the event if it's within the range\n            if (eventStart.isSameOrAfter(viewStart, 'day') && eventEnd.isSameOrBefore(viewEnd, 'day')) {\n              // Push the event into the results array\n              results.push(event);\n            }\n          } // If it's a recurring event...\n          else {\n            // Skip if the event does not recur within the view range\n            if (eventStart.isAfter(viewEnd, 'day') || eventEnd.isBefore(viewStart, 'day')) {\n              return;\n            } // Set the DTSTART and UNTIL for RRule\n\n\n            const dtStart = eventStart.clone();\n            const until = viewEnd.isBefore(eventEnd) ? viewEnd.clone().utc() : eventEnd.clone().utc(); // Create an RRuleSet\n\n            const rruleset = this._generateRuleset(event, dtStart, until); // Generate the recurring dates and loop through them\n\n\n            rruleset.all().forEach(date => {\n              // Get the rule date as a moment\n              const ruleDate = moment(date); // Subtract the UTC Offset from the rule date as we use local time for DTSTART.\n              // The reason for this is simple; if we use UTC dates for DTSTART, RRule generated\n              // dates can shift. Since we have to store the dates as UTC, we can figure out the\n              // UTC value by simply subtracting the UTC Offset (minutes) from the rule date rather\n              // than using UTC dates in the first place. This will ensure there will be no time/day\n              // shift on generated rules since they will be generated based on the local time.\n\n              ruleDate.subtract(ruleDate.utcOffset(), 'minutes'); // Skip the date if it's not in between the view start and view end\n              // to prevent generating unnecessary amount of instances and to\n              // prevent instance duplication\n\n              if (!ruleDate.isBetween(viewStart, viewEnd, 'day', '[]')) {\n                return;\n              } // Prepare the event instance\n\n\n              const eventInstance = {\n                // Generate an instance id using the event id and rule date\n                id: event.id + '_' + ruleDate.clone().utc().format('YYYYMMDD[T]HHmmss[Z]'),\n                // Set the recurringEventId on the event so we don't lose the event's origin\n                recurringEventId: event.id,\n                // Whether this is the first instance of the recurring event or not\n                isFirstInstance: event.start === ruleDate.clone().toISOString(),\n                // Get the rest of the mock-api\n                calendarId: event.calendarId,\n                title: event.title,\n                description: event.description,\n                start: ruleDate.toISOString(),\n                end: ruleDate.add(event.duration, 'minutes').toISOString(),\n                duration: event.duration,\n                allDay: event.allDay,\n                recurrence: event.recurrence\n              }; // Push the event instance to the results array\n\n              results.push(eventInstance);\n            });\n          }\n        }); // Return the response\n\n        return [200, results];\n      }); // -----------------------------------------------------------------------------------------------------\n      // @ Event - POST\n      // -----------------------------------------------------------------------------------------------------\n\n\n      this._fuseMockApiService.onPost('api/apps/calendar/event').reply(({\n        request\n      }) => {\n        // Get the event as the new event\n        const newEvent = cloneDeep(request.body.event); // Add an id to the new event\n\n        newEvent.id = FuseMockApiUtils.guid(); // Unshift the new event\n\n        this._events.unshift(newEvent); // Return the response\n\n\n        return [200, newEvent];\n      }); // -----------------------------------------------------------------------------------------------------\n      // @ Event - PATCH\n      // -----------------------------------------------------------------------------------------------------\n\n\n      this._fuseMockApiService.onPatch('api/apps/calendar/event').reply(({\n        request\n      }) => {\n        // Get the id and event\n        const id = request.body.id;\n        const event = cloneDeep(request.body.event); // Prepare the updated event\n\n        let updatedEvent = null; // Find the event and update it\n\n        this._events.forEach((item, index, events) => {\n          if (item.id === id) {\n            // Update the event\n            events[index] = assign({}, events[index], event); // Store the updated event\n\n            updatedEvent = events[index];\n          }\n        }); // Return the response\n\n\n        return [200, updatedEvent];\n      }); // -----------------------------------------------------------------------------------------------------\n      // @ Event - DELETE\n      // -----------------------------------------------------------------------------------------------------\n\n\n      this._fuseMockApiService.onDelete('api/apps/calendar/event').reply(({\n        request\n      }) => {\n        // Get the id and event\n        const id = request.params.get('id'); // Find the event and delete it\n\n        const index = this._events.findIndex(item => item.id === id);\n\n        this._events.splice(index, 1); // Return the response\n\n\n        return [200, true];\n      }); // -----------------------------------------------------------------------------------------------------\n      // @ Recurring Event - PATCH\n      // -----------------------------------------------------------------------------------------------------\n\n\n      this._fuseMockApiService.onPatch('api/apps/calendar/recurring-event').reply(({\n        request\n      }) => {\n        // Get the event, original event and mode\n        const event = cloneDeep(request.body.event);\n        const originalEvent = cloneDeep(request.body.originalEvent);\n        const mode = request.body.mode; // Find the original recurring event from db\n\n        const recurringEvent = this._events.find(item => item.id === event.recurringEventId); // Single\n\n\n        if (mode === 'single') {\n          // Create a new event from the event while ignoring the range and recurringEventId\n          const {\n            range,\n            recurringEventId\n          } = event,\n                newEvent = __rest(event, [\"range\", \"recurringEventId\"]); // Generate a unique id for the event\n\n\n          newEvent.id = FuseMockApiUtils.guid(); // Calculate the end date using the start date and the duration\n\n          newEvent.end = moment(newEvent.start).add(newEvent.duration, 'minutes'); // Null-ify the recurrence and duration\n\n          newEvent.duration = null;\n          newEvent.recurrence = null; // Push the new event to the events array\n\n          this._events.push(newEvent); // If this is the first instance of the recurring event...\n\n\n          if (originalEvent.start === recurringEvent.start) {\n            // Generate the rruleset\n            const rruleset = this._generateRuleset(recurringEvent, moment(recurringEvent.start), moment(recurringEvent.end).utc()); // Generate the dates using rruleset and get the 2nd date from start\n\n\n            const ruleDate = moment(rruleset.all((date, i) => i < 2)[1]); // Subtract the UTC Offset from the rule date as we use local time for DTSTART.\n            // The reason for this is simple; if we use UTC dates for DTSTART, RRule generated\n            // dates can shift. Since we have to store the dates as UTC, we can figure out the\n            // UTC value by simply subtracting the UTC Offset (minutes) from the rule date rather\n            // than using UTC dates in the first place. This will ensure there will be no time/day\n            // shift on generated rules since they will be generated based on the local time.\n\n            ruleDate.subtract(ruleDate.utcOffset(), 'minutes'); // Update the recurring event's start date\n\n            recurringEvent.start = ruleDate.toISOString();\n          } // Otherwise...\n          else {\n            // Add a new exception for the recurring event that ignores this single event's start date\n            this._exceptions.push({\n              id: FuseMockApiUtils.guid(),\n              eventId: originalEvent.recurringEventId,\n              exdate: moment(originalEvent.start).toISOString()\n            });\n          }\n        } // Future\n\n\n        if (mode === 'future') {\n          // Update the end date\n          recurringEvent.end = moment(originalEvent.start).subtract(1, 'day').endOf('day').toISOString(); // Parse the recurrence rules from the original event\n\n          const parsedRules = {};\n          originalEvent.recurrence.split(';').forEach(rule => {\n            const parsedRule = rule.split('=');\n            parsedRules[parsedRule[0]] = parsedRule[1];\n          }); // Add/Update the UNTIL rule\n\n          parsedRules['UNTIL'] = moment(recurringEvent.end).utc().format('YYYYMMDD[T]HHmmss[Z]'); // Generate the rule string from the parsed rules\n\n          const rules = [];\n          Object.keys(parsedRules).forEach(key => {\n            rules.push(key + '=' + parsedRules[key]);\n          }); // Update the recurrence on the original recurring event\n\n          recurringEvent.recurrence = rules.join(';'); // Create a new event from the event while ignoring the recurringEventId\n\n          const {\n            recurringEventId\n          } = event,\n                newEvent = __rest(event, [\"recurringEventId\"]); // Generate a unique id for the event\n\n\n          newEvent.id = FuseMockApiUtils.guid(); // Push the new event to the events array\n\n          this._events.push(newEvent);\n        } // All\n\n\n        if (mode === 'all') {\n          // Find the event index\n          const eventIndex = this._events.findIndex(item => item.id === event.recurringEventId); // Update the recurring event\n\n\n          this._events[eventIndex] = assign({}, this._events[eventIndex], omit(event, ['id', 'recurringEventId', 'range']));\n        } // Return the response\n\n\n        return [200, true];\n      }); // -----------------------------------------------------------------------------------------------------\n      // @ Recurring Event - DELETE\n      // -----------------------------------------------------------------------------------------------------\n\n\n      this._fuseMockApiService.onDelete('api/apps/calendar/recurring-event').reply(({\n        request\n      }) => {\n        var _a; // Get the event and mode\n\n\n        const event = JSON.parse((_a = request.params.get('event')) !== null && _a !== void 0 ? _a : '');\n        const mode = request.params.get('mode'); // Find the recurring event\n\n        const recurringEvent = this._events.find(item => item.id === event.recurringEventId); // Single\n\n\n        if (mode === 'single') {\n          // If this is the first instance of the recurring event...\n          if (event.start === recurringEvent.start) {\n            // Generate the rruleset\n            const rruleset = this._generateRuleset(recurringEvent, moment(recurringEvent.start), moment(recurringEvent.end).utc()); // Generate the dates using rruleset and get the 2nd date from start\n\n\n            const ruleDate = moment(rruleset.all((date, i) => i < 2)[1]); // Subtract the UTC Offset from the rule date as we use local time for DTSTART.\n            // The reason for this is simple; if we use UTC dates for DTSTART, RRule generated\n            // dates can shift. Since we have to store the dates as UTC, we can figure out the\n            // UTC value by simply subtracting the UTC Offset (minutes) from the rule date rather\n            // than using UTC dates in the first place. This will ensure there will be no time/day\n            // shift on generated rules since they will be generated based on the local time.\n\n            ruleDate.subtract(ruleDate.utcOffset(), 'minutes'); // Update the recurring event's start date\n\n            recurringEvent.start = ruleDate.toISOString();\n          } // Otherwise...\n          else {\n            // Add a new exception for the recurring event that ignores this single event's start date\n            this._exceptions.push({\n              id: FuseMockApiUtils.guid(),\n              eventId: event.recurringEventId,\n              exdate: moment(event.start).toISOString()\n            });\n          }\n        } // Future\n\n\n        if (mode === 'future') {\n          // Update the end date of the event\n          recurringEvent.end = moment(event.start).subtract(1, 'day').endOf('day').toISOString(); // Parse the recurrence rules of the event\n\n          const parsedRules = {};\n          recurringEvent.recurrence.split(';').forEach(rule => {\n            const parsedRule = rule.split('=');\n            parsedRules[parsedRule[0]] = parsedRule[1];\n          }); // Add/Update the UNTIL rule\n\n          parsedRules['UNTIL'] = moment(event.end).utc().format('YYYYMMDD[T]HHmmss[Z]'); // Generate the rule string from the parsed rules\n\n          const rules = [];\n          Object.keys(parsedRules).forEach(key => {\n            rules.push(key + '=' + parsedRules[key]);\n          }); // Update the recurrence of the event\n\n          recurringEvent.recurrence = rules.join(';');\n        } // All\n\n\n        if (mode === 'all') {\n          // Find the event and delete it\n          const index = this._events.findIndex(item => item.id === event.recurringEventId);\n\n          this._events.splice(index, 1);\n        } // Return the response\n\n\n        return [200, true];\n      }); // -----------------------------------------------------------------------------------------------------\n      // @ Settings - GET\n      // -----------------------------------------------------------------------------------------------------\n\n\n      this._fuseMockApiService.onGet('api/apps/calendar/settings').reply(() => [200, cloneDeep(this._settings)]); // -----------------------------------------------------------------------------------------------------\n      // @ Settings - PATCH\n      // -----------------------------------------------------------------------------------------------------\n\n\n      this._fuseMockApiService.onPatch('api/apps/calendar/settings').reply(({\n        request\n      }) => {\n        // Get the settings\n        const settings = cloneDeep(request.body.settings); // Store the updated settings\n\n        this._settings = settings; // Return the response\n\n        return [200, settings];\n      }); // -----------------------------------------------------------------------------------------------------\n      // @ Weekdays - GET\n      // -----------------------------------------------------------------------------------------------------\n\n\n      this._fuseMockApiService.onGet('api/apps/calendar/weekdays').reply(() => {\n        // Clone the weekdays\n        const weekdays = cloneDeep(this._weekdays); // If the startWeekOn setting is set to Sunday...\n\n        if (this._settings.startWeekOn === 0) {\n          // Move the Sunday to the beginning\n          weekdays.unshift(weekdays.pop());\n        } // If the startWeekOn is set to Saturday...\n\n\n        if (this._settings.startWeekOn === 6) {\n          // Move the Sunday to the beginning\n          weekdays.unshift(weekdays.pop()); // Then move the Saturday to the beginning\n\n          weekdays.unshift(weekdays.pop());\n        } // Return the response\n\n\n        return [200, weekdays];\n      });\n    } // -----------------------------------------------------------------------------------------------------\n    // @ Private methods\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\r\n     * Generates an RRuleSet from given event\r\n     *\r\n     * @param event\r\n     * @param dtStart\r\n     * @param until\r\n     * @private\r\n     */\n\n\n    _generateRuleset(event, dtStart, until) {\n      // Parse the recurrence rules\n      const parsedRules = {};\n      event.recurrence.split(';').forEach(rule => {\n        // Split the rule\n        const parsedRule = rule.split('='); // Omit UNTIL or COUNT from the parsed rules since we only\n        // need them for calculating the event's end date. We will\n        // add an UNTIL later based on the above calculations.\n\n        if (parsedRule[0] === 'UNTIL' || parsedRule[0] === 'COUNT') {\n          return;\n        } // Add the rule to the parsed rules\n\n\n        parsedRules[parsedRule[0]] = parsedRule[1];\n      }); // Generate the rule array from the parsed rules\n\n      const rules = [];\n      Object.keys(parsedRules).forEach(key => {\n        rules.push(key + '=' + parsedRules[key]);\n      }); // Prepare the ruleSet\n\n      const ruleSet = []; // Add DTSTART\n\n      ruleSet.push('DTSTART:' + dtStart.format('YYYYMMDD[T]HHmmss[Z]')); // Add RRULE\n\n      ruleSet.push('RRULE:' + rules.join(';') + ';UNTIL=' + until.format('YYYYMMDD[T]HHmmss[Z]')); // Find and add any available exceptions to the rule\n\n      this._exceptions.forEach(item => {\n        // If the item is an exception to this event...\n        if (item.eventId === event.id) {\n          // Add it as an EXDATE to the rrule\n          ruleSet.push('EXDATE:' + moment(item.exdate).format('YYYYMMDD[T]HHmmss[Z]'));\n        }\n      }); // Create an RRuleSet from the ruleSet array\n\n\n      return rrulestr(ruleSet.join('\\n'), {\n        forceset: true\n      });\n    }\n\n  }\n\n  CalendarMockApi.ɵfac = function CalendarMockApi_Factory(t) {\n    return new (t || CalendarMockApi)(i0.ɵɵinject(i1.FuseMockApiService));\n  };\n\n  CalendarMockApi.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: CalendarMockApi,\n    factory: CalendarMockApi.ɵfac,\n    providedIn: 'root'\n  });\n  return CalendarMockApi;\n})();","map":null,"metadata":{},"sourceType":"module"}